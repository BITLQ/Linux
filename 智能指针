# learngit

 浅析智能指针二

 本篇博客继《浅析智能指针一》 继续对智能指针的理解进行分析；

 主要简述要点：shared_ptr智能指针不能解决的问题：循环引用问题；
               weak_ptr解决循环引用的问题；
               模拟定制删除器的实现；


-----------------------------------------------------------------------


/*  在上一篇博客中我们认识到了智能指针，并且了解到它的功能强大，但是，再强大的东西也有它的
弊端， 而循环引用就是它的弊端，关于循环引用的概念，我们举个例子来说明：   */
//
#include<iostream>
#include<boost\shared_ptr.hpp>
#include<boost\weak_ptr.hpp>

using namespace boost;
using namespace std;


struct Node
{
	boost::shared_ptr<Node> _next;
	boost::shared_ptr<Node> _prve;

	~Node()
	{
		cout<<"~Node"<<endl;
	}
	
};

void test()
{
	boost::shared_ptr <Node> s1(new Node);
	boost::shared_ptr <Node> s2(new Node);

	//我们让s1和s2两个结点连起来
	s1->_next = s2;
	s2->_prve = s1;

	cout<<s1.use_count() <<endl;
	cout<<s2.use_count() <<endl;
}

int main()
{
	test();
	system("pause");
	return 0;
}

/* 链表我们都知道吧，上面只是简单的用智能指针试着来维护我们的节点指针；
我们来看结果，计数器显示的是2，2； 这个没问题吧，可是却没有调用析构函数，这是什么鬼！
是不是和你想的不一样？ 既然shared_ptr智能指针就是解决多个指针指向同一块空间的，那么
为什么这里就不行了呢？ 下面，我们来画图进行分析！ */


/*  看图中的指向关系，我们现在只有两个结点，不考虑什么特殊情况，看图中的指向关系，按照我们
的代码，将两个节点连了起来， s1指向的结点的_next指向s2，s2指向的结点的_prve指向s1，按照我们
构造和析构顺序严格相反的原则，我们先释放s2指向的这块空间，就必须释放s2里_prve，想要释放_prve
，就得先释放s1，但是要释放s1，就必须先释放s1中的_next所指向的空间，也就是s2，好了，循环就这样
开始了！  画个图就是这样： */

/* 这就是循环引用问题，既然存在了这样的问题，那么必然需要来解决，这样，也就产生了weak_ptr(弱指针)；
weak_ptr: 和shared_ptr一样也引自boost库，但是weak_ptr是不能单独使用的，必须和shared_ptr配合使用；
那么，我们下面来看看weak_ptr是如何使用并且解决循环引用的问题的！ */

#include<iostream>
#include<boost\shared_ptr.hpp>
#include<boost\weak_ptr.hpp>

using namespace boost;
using namespace std;


struct Node
{
	/*boost::shared_ptr<Node> _next;
	boost::shared_ptr<Node> _prve;*/

	boost::weak_ptr <Node> _next;//声明为弱指针
	boost::weak_ptr <Node> _prve;//声明为弱指针


	~Node()
	{
		cout<<"~Node"<<endl;
	}
	
};

void test()
{
	boost::shared_ptr <Node> s1(new Node);
	boost::shared_ptr <Node> s2(new Node);

	//我们让s1和s2两个结点连起来
	s1->_next = s2;
	s2->_prve = s1;

	cout<<s1.use_count() <<endl;
	cout<<s2.use_count() <<endl;
}

int main()
{
	test();
	system("pause");
	return 0;
}

/* 将_next和_prve声明为弱指针，和外面的shared_ptr声明的节点指针配合使用，下面看看结果!*/


/* 接下来就是模拟实现定置删除器了，在上一篇博客中我们对什么是定置删除器的概念，和对库里的
定置删除器进行了使用，那么，现在我们就对定置删除器模拟实现，注意我们的模拟实现和库里的区别；
*/

#include<iostream>
#include<cstdio>

using namespace std;

//注意对（）的重载；
struct Fclose//对文件的关闭
{
	void operator()(void* ptr)
	{
		cout<<"Fclose"<<endl;
		fclose((FILE*) ptr);
	}
};


struct Default//默认的删除器
{
	void operator()(void* ptr)
	{
		cout<<"~Free()"<<endl;
		delete ptr;
	}
};

//注意：两个模板参数，第二个模板参数有默认值；
template<typename T,typename D = Default>
class SharedPtr
{
public:
	SharedPtr ( T* ptr)
		:_ptr(ptr)
		,_pcount(new int(1))
		,_del(D())
	{}

	SharedPtr(SharedPtr<T,D>& sp)
	{
		_ptr = sp._ptr ;
		_pcount = sp._pcount ;
		_pcount++;
	}

	~SharedPtr ()
	{
		if(--(*_pcount) == 0)
		{
			_del(_ptr);//注意对（）重载的使用；
			delete _pcount;
		}
	}

	T& operator*()
	{
		return *_ptr;
	}

	T* operator->()
	{
		return _ptr;
	}

	SharedPtr<T,D>& operator=(SharedPtr<T,D> sp)
	{
		std::swap(_ptr,sp._ptr );
		std::swap(_pcount,sp._pcount );
		return *this;
	}
private:
	T* _ptr;
	int* _pcount;
	D _del;//删除器类型成员；
};



int main()
{
	SharedPtr<FILE,Fclose> s( fopen("test2.txt","w"));

	SharedPtr<int> p(new int);//测试默认删除类型；

	//system("pause");
	return 0;
}

/*以上就是对定置删除器的模拟实现；
注意点： 对成员 _del的准确认识；
         对（）的重载；
         对模板参数的使用；*/
//注意若使用system("pause")使程序停下来看结果的话，注意析构函数调用的位置！
//完！
